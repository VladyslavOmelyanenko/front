---
import { client } from "../lib/sanity.js";
import { urlFor } from "../lib/sanity.js";
import Layout from "../layouts/FullBleedLayout.astro";

const data = await client.fetch(`
  *[_type == "homepage"][0]{
    featuredImages[]{
      asset->{
        _id,
        metadata { dimensions { width, height } }
      },
      alt
    }
  }
`);

const images = (data?.featuredImages ?? []).filter((img) => img?.asset);

// Build LOW + HI urls from the SAME data
const lowResUrls = images.map((img) =>
  urlFor(img.asset).width(64).quality(20).url()
);

const hiResUrls = images.map((img) =>
  urlFor(img.asset).width(1920).quality(85).url()
);
---

<Layout>
  <div class="image-scroll" id="imageScroll">
    {images.map((img, i) => {
      const w = img.asset?.metadata?.dimensions?.width ?? 1;
      const h = img.asset?.metadata?.dimensions?.height ?? 1;
  
      return (
        <img
          class="scroll-image is-loading"
          src={lowResUrls[i]}
          data-hi={hiResUrls[i]}
          alt={img.alt ?? "Image"}
          width={w}
          height={h}
          loading="lazy"
          decoding="async"
        />
      );
    })}
  </div>
  
</Layout>


<script>
  (function () {
    const cleanupMap = new WeakMap();

    function findScroller(el) {
      let p = el.parentElement;
      while (p) {
        const oy = getComputedStyle(p).overflowY;
        if ((oy === "auto" || oy === "scroll") && p.scrollHeight > p.clientHeight)
          return p;
        p = p.parentElement;
      }
      return null; // viewport
    }

    function init() {
      const container = document.getElementById("imageScroll");
      if (!(container instanceof HTMLElement)) return;

      if (container.dataset.inf3Inited === "1") return;
      container.dataset.inf3Inited = "1";

      const originals = Array.from(container.querySelectorAll("img.scroll-image"));
      if (!originals.length) return;

      const scroller = findScroller(container);

      function getScrollTop() {
        return scroller ? scroller.scrollTop : window.scrollY;
      }
      function setScrollTop(v) {
        if (scroller) scroller.scrollTop = v;
        else window.scrollTo(0, v);
      }

      // Low -> hi near viewport
      const hiObserver = new IntersectionObserver(
        (entries) => {
          for (const e of entries) {
            if (!e.isIntersecting) continue;
            const img = e.target;
            if (!(img instanceof HTMLImageElement)) continue;

            const hi = img.getAttribute("data-hi");
            if (!hi || img.dataset.upgraded === "1") {
              hiObserver.unobserve(img);
              continue;
            }

            img.dataset.upgraded = "1";

            const pre = new Image();
            pre.onload = () => {
              img.src = hi;
              img.classList.remove("is-loading");
              hiObserver.unobserve(img);
            };
            pre.src = hi;
          }
        },
        { root: scroller, rootMargin: "300px 0px", threshold: 0 }
      );

      function observeHi(scope) {
        scope.querySelectorAll("img.scroll-image").forEach((img) => {
          if (!(img instanceof HTMLImageElement)) return;
          if (!img.getAttribute("data-hi")) return;
          if (img.dataset.upgraded === "1") return;
          hiObserver.observe(img);
        });
      }

      // Wrap the original images into a "block"
      const block = document.createElement("div");
      block.className = "image-scroll-block";
      while (container.firstChild) block.appendChild(container.firstChild);
      container.appendChild(block);

      const before = block.cloneNode(true);
      const after = block.cloneNode(true);

      if (!(before instanceof HTMLElement) || !(after instanceof HTMLElement)) return;

      before.setAttribute("aria-hidden", "true");
      after.setAttribute("aria-hidden", "true");

      container.insertBefore(before, block);
      container.appendChild(after);

      observeHi(container);

      function waitForLayout() {
        return new Promise((resolve) => {
          const start = performance.now();
          (function check() {
            if (block.getBoundingClientRect().height > 0) {
              resolve(undefined);
              return;
            }
            if (performance.now() - start > 2000) {
              resolve(undefined);
              return;
            }
            requestAnimationFrame(check);
          })();
        });
      }

      let ticking = false;

      function recenterIfNeeded() {
        if (ticking) return;
        ticking = true;

        requestAnimationFrame(() => {
          ticking = false;

          const h = block.getBoundingClientRect().height;
          if (!h) return;

          const y = getScrollTop();

          // Keep scroll within the middle third: [0.5h, 1.5h]
          if (y < 0.5 * h) setScrollTop(y + h);
          else if (y > 1.5 * h) setScrollTop(y - h);
        });
      }

      function addScrollListener() {
        const target = scroller || window;
        target.addEventListener("scroll", recenterIfNeeded, { passive: true });
        return () => target.removeEventListener("scroll", recenterIfNeeded);
      }

      let removeScroll = null;

      waitForLayout().then(() => {
        // Start in the middle block so up/down both work immediately
        const h = block.getBoundingClientRect().height;
        setScrollTop(h);

        removeScroll = addScrollListener();
      });

      function destroy() {
        if (typeof removeScroll === "function") removeScroll();
        hiObserver.disconnect();

        // Restore DOM to original (middle) block only
        if (before.parentNode) before.parentNode.removeChild(before);
if (after.parentNode) after.parentNode.removeChild(after);rootMargin: "200px 0px"

        // Unwrap: move children back into container (optional cleanliness)
        const middle = container.querySelector(".image-scroll-block");
        if (middle instanceof HTMLElement) {
          while (middle.firstChild) container.insertBefore(middle.firstChild, middle);
          middle.remove();
        }

        delete container.dataset.inf3Inited;
        cleanupMap.delete(container);
      }

      cleanupMap.set(container, destroy);
    }

    function cleanup() {
      const container = document.getElementById("imageScroll");
      if (!(container instanceof HTMLElement)) return;
      const fn = cleanupMap.get(container);
      if (typeof fn === "function") fn();
    }

    // Bind Astro lifecycle once (no custom window props)
    const root = document.documentElement;
    if (root.dataset.inf3Bound !== "1") {
      root.dataset.inf3Bound = "1";
      document.addEventListener("astro:page-load", init);
      document.addEventListener("astro:after-swap", init);
      document.addEventListener("astro:before-swap", cleanup);
    }

    init();
  })();
</script>








<style lang="scss" is:global>
  html,
  body {
    margin: 0;
    overflow-x: hidden;
  }

  .image-scroll {
    width: 100vw;
  }

  .scroll-image {
    display: block;
    width: 100%;
    height: auto;
    object-fit: contain;
  }

  .scroll-image.is-loading {
  filter: blur(6px);
  transform: scale(1.01);
}


</style>
